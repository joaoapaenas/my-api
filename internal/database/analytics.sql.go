// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: analytics.sql

package database

import (
	"context"
	"database/sql"
)

const getAccuracyBySubject = `-- name: GetAccuracyBySubject :many
SELECT 
    s.id AS subject_id,
    s.name AS subject_name,
    s.color_hex,
    SUM(el.questions_count) AS total_questions,
    SUM(el.correct_count) AS total_correct,
    ROUND(
        (SUM(el.correct_count) * 100.0) / NULLIF(SUM(el.questions_count), 0), 
        2
    ) AS accuracy_percentage
FROM subjects s
LEFT JOIN exercise_logs el ON s.id = el.subject_id
WHERE s.deleted_at IS NULL
GROUP BY s.id, s.name, s.color_hex
HAVING total_questions > 0
ORDER BY accuracy_percentage ASC
`

type GetAccuracyBySubjectRow struct {
	SubjectID          string          `json:"subject_id"`
	SubjectName        string          `json:"subject_name"`
	ColorHex           sql.NullString  `json:"color_hex"`
	TotalQuestions     sql.NullFloat64 `json:"total_questions"`
	TotalCorrect       sql.NullFloat64 `json:"total_correct"`
	AccuracyPercentage float64         `json:"accuracy_percentage"`
}

func (q *Queries) GetAccuracyBySubject(ctx context.Context) ([]GetAccuracyBySubjectRow, error) {
	rows, err := q.db.QueryContext(ctx, getAccuracyBySubject)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAccuracyBySubjectRow
	for rows.Next() {
		var i GetAccuracyBySubjectRow
		if err := rows.Scan(
			&i.SubjectID,
			&i.SubjectName,
			&i.ColorHex,
			&i.TotalQuestions,
			&i.TotalCorrect,
			&i.AccuracyPercentage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccuracyByTopic = `-- name: GetAccuracyByTopic :many
SELECT 
    t.id AS topic_id,
    t.name AS topic_name,
    SUM(el.questions_count) AS total_questions,
    SUM(el.correct_count) AS total_correct,
    ROUND(
        (SUM(el.correct_count) * 100.0) / NULLIF(SUM(el.questions_count), 0), 
        2
    ) AS accuracy_percentage
FROM topics t
LEFT JOIN exercise_logs el ON t.id = el.topic_id
WHERE t.subject_id = ?
  AND t.deleted_at IS NULL
GROUP BY t.id, t.name
HAVING total_questions > 0
ORDER BY accuracy_percentage ASC
`

type GetAccuracyByTopicRow struct {
	TopicID            string          `json:"topic_id"`
	TopicName          string          `json:"topic_name"`
	TotalQuestions     sql.NullFloat64 `json:"total_questions"`
	TotalCorrect       sql.NullFloat64 `json:"total_correct"`
	AccuracyPercentage float64         `json:"accuracy_percentage"`
}

func (q *Queries) GetAccuracyByTopic(ctx context.Context, subjectID string) ([]GetAccuracyByTopicRow, error) {
	rows, err := q.db.QueryContext(ctx, getAccuracyByTopic, subjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAccuracyByTopicRow
	for rows.Next() {
		var i GetAccuracyByTopicRow
		if err := rows.Scan(
			&i.TopicID,
			&i.TopicName,
			&i.TotalQuestions,
			&i.TotalCorrect,
			&i.AccuracyPercentage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActivityHeatmap = `-- name: GetActivityHeatmap :many
SELECT 
    strftime('%Y-%m-%d', started_at) AS study_date,
    COUNT(DISTINCT id) AS sessions_count,
    COALESCE(SUM(net_duration_seconds), 0) AS total_seconds
FROM study_sessions
WHERE finished_at IS NOT NULL
  AND datetime(started_at) >= datetime('now', '-' || CAST(? AS TEXT) || ' days')
GROUP BY study_date
ORDER BY study_date DESC
`

type GetActivityHeatmapRow struct {
	StudyDate     interface{} `json:"study_date"`
	SessionsCount int64       `json:"sessions_count"`
	TotalSeconds  interface{} `json:"total_seconds"`
}

func (q *Queries) GetActivityHeatmap(ctx context.Context, dollar_1 string) ([]GetActivityHeatmapRow, error) {
	rows, err := q.db.QueryContext(ctx, getActivityHeatmap, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActivityHeatmapRow
	for rows.Next() {
		var i GetActivityHeatmapRow
		if err := rows.Scan(&i.StudyDate, &i.SessionsCount, &i.TotalSeconds); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTimeReportBySubject = `-- name: GetTimeReportBySubject :many

SELECT 
    s.id AS subject_id,
    s.name AS subject_name,
    s.color_hex,
    COUNT(ss.id) AS sessions_count,
    ROUND(COALESCE(SUM(ss.net_duration_seconds), 0) / 3600.0, 2) AS total_hours_net
FROM subjects s
LEFT JOIN study_sessions ss ON s.id = ss.subject_id 
    AND ss.finished_at IS NOT NULL
    AND (? = '' OR ss.started_at >= ?)
    AND (? = '' OR ss.started_at <= ?)
WHERE s.deleted_at IS NULL
GROUP BY s.id, s.name, s.color_hex
HAVING sessions_count > 0
ORDER BY total_hours_net DESC
`

type GetTimeReportBySubjectParams struct {
	Column1     interface{} `json:"column_1"`
	StartedAt   string      `json:"started_at"`
	Column3     interface{} `json:"column_3"`
	StartedAt_2 string      `json:"started_at_2"`
}

type GetTimeReportBySubjectRow struct {
	SubjectID     string         `json:"subject_id"`
	SubjectName   string         `json:"subject_name"`
	ColorHex      sql.NullString `json:"color_hex"`
	SessionsCount int64          `json:"sessions_count"`
	TotalHoursNet float64        `json:"total_hours_net"`
}

// Analytics Queries for Study App
func (q *Queries) GetTimeReportBySubject(ctx context.Context, arg GetTimeReportBySubjectParams) ([]GetTimeReportBySubjectRow, error) {
	rows, err := q.db.QueryContext(ctx, getTimeReportBySubject,
		arg.Column1,
		arg.StartedAt,
		arg.Column3,
		arg.StartedAt_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTimeReportBySubjectRow
	for rows.Next() {
		var i GetTimeReportBySubjectRow
		if err := rows.Scan(
			&i.SubjectID,
			&i.SubjectName,
			&i.ColorHex,
			&i.SessionsCount,
			&i.TotalHoursNet,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
